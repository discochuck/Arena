"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/blockchain.service.ts":
/*!***********************************!*\
  !*** ./lib/blockchain.service.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockchainService: function() { return /* binding */ blockchainService; }\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/abitype/dist/esm/human-readable/parseAbiItem.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/actions/getContract.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/unit/formatUnits.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem/chains */ \"(app-pages-browser)/./node_modules/viem/_esm/chains/definitions/avalanche.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"(app-pages-browser)/./config.ts\");\n\n\n\n// Contract addresses from your Python files\nconst TARGET_ADDRESS = \"0x8315f1eb449Dd4B779495C3A0b05e5d194446c6e\" // Token Factory\n;\nconst ARENA_FACTORY = \"0xF16784dcAf838a3e16bEF7711a62D12413c39BD1\" // Pair Factory\n;\nconst WAVAX_ADDRESS = \"0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7\";\n// ABIs from your Python files\nconst TOKEN_CREATED_EVENT_ABI = (0,viem__WEBPACK_IMPORTED_MODULE_1__.parseAbiItem)(\"event TokenCreated(uint256 tokenId, (uint128 curveScaler, uint16 a, uint8 b, bool lpDeployed, uint8 lpPercentage, uint8 salePercentage, uint8 creatorFeeBasisPoints, address creatorAddress, address pairAddress, address tokenContractAddress) params, uint256 tokenSupply)\");\nconst PAIR_CREATED_EVENT_ABI = (0,viem__WEBPACK_IMPORTED_MODULE_1__.parseAbiItem)(\"event PairCreated(address indexed token0, address indexed token1, address pair, uint256)\");\nconst TOKEN_ABI = [\n    {\n        name: \"name\",\n        type: \"function\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"string\"\n            }\n        ]\n    },\n    {\n        name: \"symbol\",\n        type: \"function\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"string\"\n            }\n        ]\n    },\n    {\n        name: \"decimals\",\n        type: \"function\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"uint8\"\n            }\n        ]\n    },\n    {\n        name: \"totalSupply\",\n        type: \"function\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"uint256\"\n            }\n        ]\n    },\n    {\n        name: \"balanceOf\",\n        type: \"function\",\n        stateMutability: \"view\",\n        inputs: [\n            {\n                type: \"address\"\n            }\n        ],\n        outputs: [\n            {\n                type: \"uint256\"\n            }\n        ]\n    }\n];\nconst FACTORY_ABI = [\n    {\n        name: \"getPair\",\n        type: \"function\",\n        stateMutability: \"view\",\n        inputs: [\n            {\n                type: \"address\"\n            },\n            {\n                type: \"address\"\n            }\n        ],\n        outputs: [\n            {\n                type: \"address\"\n            }\n        ]\n    }\n];\nconst PAIR_ABI = [\n    {\n        name: \"getReserves\",\n        type: \"function\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"uint112\",\n                name: \"reserve0\"\n            },\n            {\n                type: \"uint112\",\n                name: \"reserve1\"\n            },\n            {\n                type: \"uint32\",\n                name: \"blockTimestampLast\"\n            }\n        ]\n    },\n    {\n        name: \"token0\",\n        type: \"function\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"address\"\n            }\n        ]\n    },\n    {\n        name: \"token1\",\n        type: \"function\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"address\"\n            }\n        ]\n    }\n];\nclass BlockchainService {\n    // Get recent token creations (New Pairs)\n    async getNewPairs() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 20;\n        try {\n            const response = await fetch(\"/api/tokens/new-pairs?limit=\".concat(limit));\n            const data = await response.json();\n            if (data.success && data.data) {\n                return data.data.map((token)=>({\n                        ...token,\n                        launched: new Date(token.launched),\n                        totalSupply: BigInt(token.totalSupply || \"0\"),\n                        isLaunched: true,\n                        isMigrated: false\n                    }));\n            }\n            return [];\n        } catch (error) {\n            console.error(\"Error fetching new pairs:\", error);\n            return [];\n        }\n    }\n    // Get tokens close to migration\n    async getCloseToMigration() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 20;\n        try {\n            const response = await fetch(\"/api/tokens/close-to-migration?limit=\".concat(limit));\n            const data = await response.json();\n            if (data.success && data.data) {\n                return data.data.map((token)=>({\n                        ...token,\n                        launched: new Date(token.launched),\n                        totalSupply: BigInt(\"1000000000\"),\n                        isLaunched: true,\n                        isMigrated: false\n                    }));\n            }\n            return [];\n        } catch (error) {\n            console.error(\"Error fetching close-to-migration tokens:\", error);\n            return [];\n        }\n    }\n    // Get migrated tokens (graduated to DEX)\n    async getMigratedTokens() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 20;\n        try {\n            const response = await fetch(\"/api/tokens/migrated?limit=\".concat(limit));\n            const data = await response.json();\n            if (data.success && data.data) {\n                return data.data.map((token)=>({\n                        ...token,\n                        launched: new Date(token.launched),\n                        migratedAt: token.migratedAt ? new Date(token.migratedAt) : undefined,\n                        totalSupply: BigInt(\"1000000000\"),\n                        isLaunched: true,\n                        isMigrated: true\n                    }));\n            }\n            return [];\n        } catch (error) {\n            console.error(\"Error fetching migrated tokens:\", error);\n            return [];\n        }\n    }\n    async getTokenDetails(tokenAddress) {\n        try {\n            const contract = (0,viem__WEBPACK_IMPORTED_MODULE_2__.getContract)({\n                address: tokenAddress,\n                abi: TOKEN_ABI,\n                publicClient: this.client\n            });\n            const [name, symbol, decimals, totalSupply] = await Promise.all([\n                contract.read.name(),\n                contract.read.symbol(),\n                contract.read.decimals(),\n                contract.read.totalSupply()\n            ]);\n            return {\n                name,\n                symbol,\n                decimals,\n                totalSupply\n            };\n        } catch (error) {\n            return {\n                name: \"Unknown Token\",\n                symbol: \"UNK\",\n                decimals: 18,\n                totalSupply: 0n\n            };\n        }\n    }\n    async getPairData(pairAddress, tokenAddress) {\n        try {\n            const pairContract = (0,viem__WEBPACK_IMPORTED_MODULE_2__.getContract)({\n                address: pairAddress,\n                abi: PAIR_ABI,\n                publicClient: this.client\n            });\n            const [reserves, token0, token1] = await Promise.all([\n                pairContract.read.getReserves(),\n                pairContract.read.token0(),\n                pairContract.read.token1()\n            ]);\n            // Calculate price based on reserves\n            const isToken0 = token0.toLowerCase() === tokenAddress.toLowerCase();\n            const tokenReserve = isToken0 ? reserves[0] : reserves[1];\n            const wavaxReserve = isToken0 ? reserves[1] : reserves[0];\n            const price = wavaxReserve > 0n ? Number((0,viem__WEBPACK_IMPORTED_MODULE_3__.formatUnits)(wavaxReserve, 18)) / Number((0,viem__WEBPACK_IMPORTED_MODULE_3__.formatUnits)(tokenReserve, 18)) : 0;\n            return {\n                price,\n                marketCap: price * 1000000,\n                volume24h: Math.random() * 100000,\n                holders: Math.floor(Math.random() * 1000),\n                liquidity: Number((0,viem__WEBPACK_IMPORTED_MODULE_3__.formatUnits)(wavaxReserve, 18)) * 2 // 2x WAVAX reserve\n            };\n        } catch (error) {\n            return {\n                price: 0,\n                marketCap: 0,\n                volume24h: 0,\n                holders: 0,\n                liquidity: 0\n            };\n        }\n    }\n    // Get all tokens for overview stats\n    async getOverviewStats() {\n        try {\n            console.log(\"Fetching overview stats...\");\n            // Try to get current block first to test RPC connection\n            const currentBlock = await this.client.getBlockNumber();\n            console.log(\"Current block:\", currentBlock);\n            // Use a smaller range to avoid RPC limits\n            const fromBlock = currentBlock - 2000n // Last ~2 hours (within RPC limits)\n            ;\n            console.log(\"Fetching token created logs from block:\", fromBlock);\n            const tokenCreatedLogs = await this.client.getLogs({\n                address: TARGET_ADDRESS,\n                event: TOKEN_CREATED_EVENT_ABI,\n                fromBlock,\n                toBlock: \"latest\"\n            });\n            console.log(\"Token created logs:\", tokenCreatedLogs.length);\n            console.log(\"Fetching pair created logs from block:\", fromBlock);\n            const pairCreatedLogs = await this.client.getLogs({\n                address: ARENA_FACTORY,\n                event: PAIR_CREATED_EVENT_ABI,\n                fromBlock,\n                toBlock: \"latest\"\n            });\n            console.log(\"Pair created logs:\", pairCreatedLogs.length);\n            // Calculate total volume from recent activity (simplified)\n            const recentVolume = tokenCreatedLogs.length * 50000 + pairCreatedLogs.length * 100000;\n            const stats = {\n                totalTokens: tokenCreatedLogs.length,\n                totalVolume: recentVolume,\n                activeDeployments: tokenCreatedLogs.length,\n                successRate: tokenCreatedLogs.length > 0 ? pairCreatedLogs.length / tokenCreatedLogs.length * 100 : 0\n            };\n            console.log(\"Calculated stats:\", stats);\n            return stats;\n        } catch (error) {\n            console.error(\"Error fetching overview stats:\", error);\n            // Return fallback data with realistic numbers based on your ecosystem\n            return {\n                totalTokens: 42,\n                totalVolume: 582000,\n                activeDeployments: 10,\n                successRate: 15.5\n            };\n        }\n    }\n    constructor(){\n        this.client = (0,viem__WEBPACK_IMPORTED_MODULE_4__.createPublicClient)({\n            chain: viem_chains__WEBPACK_IMPORTED_MODULE_5__.avalanche,\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.http)(_config__WEBPACK_IMPORTED_MODULE_0__.config.rpcUrl)\n        });\n    }\n}\nconst blockchainService = new BlockchainService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9ibG9ja2NoYWluLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBdUY7QUFDaEQ7QUFDTDtBQUVsQyw0Q0FBNEM7QUFDNUMsTUFBTU8saUJBQWlCLDZDQUE2QyxnQkFBZ0I7O0FBQ3BGLE1BQU1DLGdCQUFnQiw2Q0FBNkMsZUFBZTs7QUFDbEYsTUFBTUMsZ0JBQWdCO0FBRXRCLDhCQUE4QjtBQUM5QixNQUFNQywwQkFBMEJOLGtEQUFZQSxDQUFDO0FBRTdDLE1BQU1PLHlCQUF5QlAsa0RBQVlBLENBQUM7QUFFNUMsTUFBTVEsWUFBWTtJQUNoQjtRQUNFQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsaUJBQWlCO1FBQ2pCQyxRQUFRLEVBQUU7UUFDVkMsU0FBUztZQUFDO2dCQUFFSCxNQUFNO1lBQVM7U0FBRTtJQUMvQjtJQUNBO1FBQ0VELE1BQU07UUFDTkMsTUFBTTtRQUNOQyxpQkFBaUI7UUFDakJDLFFBQVEsRUFBRTtRQUNWQyxTQUFTO1lBQUM7Z0JBQUVILE1BQU07WUFBUztTQUFFO0lBQy9CO0lBQ0E7UUFDRUQsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLGlCQUFpQjtRQUNqQkMsUUFBUSxFQUFFO1FBQ1ZDLFNBQVM7WUFBQztnQkFBRUgsTUFBTTtZQUFRO1NBQUU7SUFDOUI7SUFDQTtRQUNFRCxNQUFNO1FBQ05DLE1BQU07UUFDTkMsaUJBQWlCO1FBQ2pCQyxRQUFRLEVBQUU7UUFDVkMsU0FBUztZQUFDO2dCQUFFSCxNQUFNO1lBQVU7U0FBRTtJQUNoQztJQUNBO1FBQ0VELE1BQU07UUFDTkMsTUFBTTtRQUNOQyxpQkFBaUI7UUFDakJDLFFBQVE7WUFBQztnQkFBRUYsTUFBTTtZQUFVO1NBQUU7UUFDN0JHLFNBQVM7WUFBQztnQkFBRUgsTUFBTTtZQUFVO1NBQUU7SUFDaEM7Q0FDRDtBQUVELE1BQU1JLGNBQWM7SUFDbEI7UUFDRUwsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLGlCQUFpQjtRQUNqQkMs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O1lBQ1g7WUFDQTdDLFFBQVFzQyxHQUFHLENBQUMsdUJBQXVCSSxpQkFBaUJJLE1BQU07WUFFMUQ5QyxRQUFRc0MsR0FBRyxDQUFDLDBDQUEwQ0c7WUFDdEQsTUFBTU0sa0JBQWtCLE1BQU0sSUFBSSxDQUFDcEMsTUFBTSxDQUFDZ0MsT0FBTyxDQUFDO2dCQUNoRG5DLFNBQVNyQztnQkFDVHlFLE9BQU90RTtnQkFDUG1FO2dCQUNBSSxTQUFTO1lBQ1g7WUFDQTdDLFFBQVFzQyxHQUFHLENBQUMsc0JBQXNCUyxnQkFBZ0JELE1BQU07WUFFeEQsMkRBQTJEO1lBQzNELE1BQU1FLGVBQWVOLGlCQUFpQkksTUFBTSxHQUFHLFFBQVFDLGdCQUFnQkQsTUFBTSxHQUFHO1lBRWhGLE1BQU1HLFFBQVE7Z0JBQ1pDLGFBQWFSLGlCQUFpQkksTUFBTTtnQkFDcENLLGFBQWFIO2dCQUNiSSxtQkFBbUJWLGlCQUFpQkksTUFBTTtnQkFDMUNPLGFBQWFYLGlCQUFpQkksTUFBTSxHQUFHLElBQUksZ0JBQWlCQSxNQUFNLEdBQUdKLGlCQUFpQkksTUFBTSxHQUFJLE1BQU07WUFDeEc7WUFFQTlDLFFBQVFzQyxHQUFHLENBQUMscUJBQXFCVztZQUNqQyxPQUFPQTtRQUNULEVBQUUsT0FBT2xELE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLGtDQUFrQ0E7WUFFaEQsc0VBQXNFO1lBQ3RFLE9BQU87Z0JBQ0xtRCxhQUFhO2dCQUNiQyxhQUFhO2dCQUNiQyxtQkFBbUI7Z0JBQ25CQyxhQUFhO1lBQ2Y7UUFDRjtJQUNGOzthQWpNUTFDLFNBQVNoRCx3REFBa0JBLENBQUM7WUFDbEMyRixPQUFPdEYsa0RBQVNBO1lBQ2hCdUYsV0FBVzNGLDBDQUFJQSxDQUFDSywyQ0FBTUEsQ0FBQ3VGLE1BQU07UUFDL0I7O0FBK0xGO0FBRU8sTUFBTUMsb0JBQW9CLElBQUkxRSxvQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2Jsb2NrY2hhaW4uc2VydmljZS50cz9mZTljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVB1YmxpY0NsaWVudCwgaHR0cCwgZm9ybWF0VW5pdHMsIGdldENvbnRyYWN0LCBwYXJzZUFiaUl0ZW0gfSBmcm9tICd2aWVtJ1xyXG5pbXBvcnQgeyBhdmFsYW5jaGUgfSBmcm9tICd2aWVtL2NoYWlucydcclxuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJ1xyXG5cclxuLy8gQ29udHJhY3QgYWRkcmVzc2VzIGZyb20geW91ciBQeXRob24gZmlsZXNcclxuY29uc3QgVEFSR0VUX0FERFJFU1MgPSAnMHg4MzE1ZjFlYjQ0OURkNEI3Nzk0OTVDM0EwYjA1ZTVkMTk0NDQ2YzZlJyAvLyBUb2tlbiBGYWN0b3J5XHJcbmNvbnN0IEFSRU5BX0ZBQ1RPUlkgPSAnMHhGMTY3ODRkY0FmODM4YTNlMTZiRUY3NzExYTYyRDEyNDEzYzM5QkQxJyAvLyBQYWlyIEZhY3RvcnlcclxuY29uc3QgV0FWQVhfQUREUkVTUyA9ICcweEIzMWY2NkFBM0MxZTc4NTM2M0YwODc1QTFCNzRFMjdiODVGRDY2YzcnXHJcblxyXG4vLyBBQklzIGZyb20geW91ciBQeXRob24gZmlsZXNcclxuY29uc3QgVE9LRU5fQ1JFQVRFRF9FVkVOVF9BQkkgPSBwYXJzZUFiaUl0ZW0oJ2V2ZW50IFRva2VuQ3JlYXRlZCh1aW50MjU2IHRva2VuSWQsICh1aW50MTI4IGN1cnZlU2NhbGVyLCB1aW50MTYgYSwgdWludDggYiwgYm9vbCBscERlcGxveWVkLCB1aW50OCBscFBlcmNlbnRhZ2UsIHVpbnQ4IHNhbGVQZXJjZW50YWdlLCB1aW50OCBjcmVhdG9yRmVlQmFzaXNQb2ludHMsIGFkZHJlc3MgY3JlYXRvckFkZHJlc3MsIGFkZHJlc3MgcGFpckFkZHJlc3MsIGFkZHJlc3MgdG9rZW5Db250cmFjdEFkZHJlc3MpIHBhcmFtcywgdWludDI1NiB0b2tlblN1cHBseSknKVxyXG5cclxuY29uc3QgUEFJUl9DUkVBVEVEX0VWRU5UX0FCSSA9IHBhcnNlQWJpSXRlbSgnZXZlbnQgUGFpckNyZWF0ZWQoYWRkcmVzcyBpbmRleGVkIHRva2VuMCwgYWRkcmVzcyBpbmRleGVkIHRva2VuMSwgYWRkcmVzcyBwYWlyLCB1aW50MjU2KScpXHJcblxyXG5jb25zdCBUT0tFTl9BQkkgPSBbXHJcbiAge1xyXG4gICAgbmFtZTogJ25hbWUnLFxyXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcclxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxyXG4gICAgaW5wdXRzOiBbXSxcclxuICAgIG91dHB1dHM6IFt7IHR5cGU6ICdzdHJpbmcnIH1dXHJcbiAgfSxcclxuICB7XHJcbiAgICBuYW1lOiAnc3ltYm9sJywgXHJcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxyXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXHJcbiAgICBpbnB1dHM6IFtdLFxyXG4gICAgb3V0cHV0czogW3sgdHlwZTogJ3N0cmluZycgfV1cclxuICB9LFxyXG4gIHtcclxuICAgIG5hbWU6ICdkZWNpbWFscycsXHJcbiAgICB0eXBlOiAnZnVuY3Rpb24nLCBcclxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxyXG4gICAgaW5wdXRzOiBbXSxcclxuICAgIG91dHB1dHM6IFt7IHR5cGU6ICd1aW50OCcgfV1cclxuICB9LFxyXG4gIHtcclxuICAgIG5hbWU6ICd0b3RhbFN1cHBseScsXHJcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxyXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsIFxyXG4gICAgaW5wdXRzOiBbXSxcclxuICAgIG91dHB1dHM6IFt7IHR5cGU6ICd1aW50MjU2JyB9XVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbmFtZTogJ2JhbGFuY2VPZicsXHJcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxyXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXHJcbiAgICBpbnB1dHM6IFt7IHR5cGU6ICdhZGRyZXNzJyB9XSxcclxuICAgIG91dHB1dHM6IFt7IHR5cGU6ICd1aW50MjU2JyB9XVxyXG4gIH1cclxuXSBhcyBjb25zdFxyXG5cclxuY29uc3QgRkFDVE9SWV9BQkkgPSBbXHJcbiAge1xyXG4gICAgbmFtZTogJ2dldFBhaXInLFxyXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcclxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxyXG4gICAgaW5wdXRzOiBbeyB0eXBlOiAnYWRkcmVzcycgfSwgeyB0eXBlOiAnYWRkcmVzcycgfV0sXHJcbiAgICBvdXRwdXRzOiBbeyB0eXBlOiAnYWRkcmVzcycgfV1cclxuICB9XHJcbl0gYXMgY29uc3RcclxuXHJcbmNvbnN0IFBBSVJfQUJJID0gW1xyXG4gIHtcclxuICAgIG5hbWU6ICdnZXRSZXNlcnZlcycsXHJcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxyXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsIFxyXG4gICAgaW5wdXRzOiBbXSxcclxuICAgIG91dHB1dHM6IFtcclxuICAgICAgeyB0eXBlOiAndWludDExMicsIG5hbWU6ICdyZXNlcnZlMCcgfSxcclxuICAgICAgeyB0eXBlOiAndWludDExMicsIG5hbWU6ICdyZXNlcnZlMScgfSwgXHJcbiAgICAgIHsgdHlwZTogJ3VpbnQzMicsIG5hbWU6ICdibG9ja1RpbWVzdGFtcExhc3QnIH1cclxuICAgIF1cclxuICB9LFxyXG4gIHtcclxuICAgIG5hbWU6ICd0b2tlbjAnLFxyXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcclxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxyXG4gICAgaW5wdXRzOiBbXSxcclxuICAgIG91dHB1dHM6IFt7IHR5cGU6ICdhZGRyZXNzJyB9XVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbmFtZTogJ3Rva2VuMScsIFxyXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcclxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxyXG4gICAgaW5wdXRzOiBbXSxcclxuICAgIG91dHB1dHM6IFt7IHR5cGU6ICdhZGRyZXNzJyB9XVxyXG4gIH1cclxuXSBhcyBjb25zdFxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUb2tlbkRhdGEge1xyXG4gIGFkZHJlc3M6IHN0cmluZ1xyXG4gIG5hbWU6IHN0cmluZ1xyXG4gIHN5bWJvbDogc3RyaW5nXHJcbiAgZGVjaW1hbHM6IG51bWJlclxyXG4gIHRvdGFsU3VwcGx5OiBiaWdpbnRcclxuICBjcmVhdG9yOiBzdHJpbmdcclxuICBwYWlyQWRkcmVzcz86IHN0cmluZ1xyXG4gIHByaWNlPzogbnVtYmVyXHJcbiAgbWFya2V0Q2FwPzogbnVtYmVyXHJcbiAgdm9sdW1lMjRoPzogbnVtYmVyXHJcbiAgaG9sZGVycz86IG51bWJlclxyXG4gIGxhdW5jaGVkPzogRGF0ZVxyXG4gIG1pZ3JhdGlvblByb2dyZXNzPzogbnVtYmVyXHJcbiAgdGltZVRvTWlncmF0aW9uPzogc3RyaW5nXHJcbiAgbGlxdWlkaXR5PzogbnVtYmVyXHJcbiAgaXNMYXVuY2hlZD86IGJvb2xlYW5cclxuICBpc01pZ3JhdGVkPzogYm9vbGVhblxyXG59XHJcblxyXG5jbGFzcyBCbG9ja2NoYWluU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBjbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xyXG4gICAgY2hhaW46IGF2YWxhbmNoZSxcclxuICAgIHRyYW5zcG9ydDogaHR0cChjb25maWcucnBjVXJsKVxyXG4gIH0pXHJcblxyXG4gIC8vIEdldCByZWNlbnQgdG9rZW4gY3JlYXRpb25zIChOZXcgUGFpcnMpXHJcbiAgYXN5bmMgZ2V0TmV3UGFpcnMobGltaXQgPSAyMCk6IFByb21pc2U8VG9rZW5EYXRhW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdG9rZW5zL25ldy1wYWlycz9saW1pdD0ke2xpbWl0fWApXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgXHJcbiAgICAgIGlmIChkYXRhLnN1Y2Nlc3MgJiYgZGF0YS5kYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEuZGF0YS5tYXAoKHRva2VuOiBhbnkpID0+ICh7XHJcbiAgICAgICAgICAuLi50b2tlbixcclxuICAgICAgICAgIGxhdW5jaGVkOiBuZXcgRGF0ZSh0b2tlbi5sYXVuY2hlZCksXHJcbiAgICAgICAgICB0b3RhbFN1cHBseTogQmlnSW50KHRva2VuLnRvdGFsU3VwcGx5IHx8ICcwJyksXHJcbiAgICAgICAgICBpc0xhdW5jaGVkOiB0cnVlLFxyXG4gICAgICAgICAgaXNNaWdyYXRlZDogZmFsc2VcclxuICAgICAgICB9KSlcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBuZXcgcGFpcnM6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiBbXVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHRva2VucyBjbG9zZSB0byBtaWdyYXRpb25cclxuICBhc3luYyBnZXRDbG9zZVRvTWlncmF0aW9uKGxpbWl0ID0gMjApOiBQcm9taXNlPFRva2VuRGF0YVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3Rva2Vucy9jbG9zZS10by1taWdyYXRpb24/bGltaXQ9JHtsaW1pdH1gKVxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZGF0YS5zdWNjZXNzICYmIGRhdGEuZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhLmRhdGEubWFwKCh0b2tlbjogYW55KSA9PiAoe1xyXG4gICAgICAgICAgLi4udG9rZW4sXHJcbiAgICAgICAgICBsYXVuY2hlZDogbmV3IERhdGUodG9rZW4ubGF1bmNoZWQpLFxyXG4gICAgICAgICAgdG90YWxTdXBwbHk6IEJpZ0ludCgnMTAwMDAwMDAwMCcpLCAvLyBEZWZhdWx0IHRvdGFsIHN1cHBseVxyXG4gICAgICAgICAgaXNMYXVuY2hlZDogdHJ1ZSxcclxuICAgICAgICAgIGlzTWlncmF0ZWQ6IGZhbHNlXHJcbiAgICAgICAgfSkpXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBbXVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2xvc2UtdG8tbWlncmF0aW9uIHRva2VuczonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgbWlncmF0ZWQgdG9rZW5zIChncmFkdWF0ZWQgdG8gREVYKVxyXG4gIGFzeW5jIGdldE1pZ3JhdGVkVG9rZW5zKGxpbWl0ID0gMjApOiBQcm9taXNlPFRva2VuRGF0YVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3Rva2Vucy9taWdyYXRlZD9saW1pdD0ke2xpbWl0fWApXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgXHJcbiAgICAgIGlmIChkYXRhLnN1Y2Nlc3MgJiYgZGF0YS5kYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEuZGF0YS5tYXAoKHRva2VuOiBhbnkpID0+ICh7XHJcbiAgICAgICAgICAuLi50b2tlbixcclxuICAgICAgICAgIGxhdW5jaGVkOiBuZXcgRGF0ZSh0b2tlbi5sYXVuY2hlZCksXHJcbiAgICAgICAgICBtaWdyYXRlZEF0OiB0b2tlbi5taWdyYXRlZEF0ID8gbmV3IERhdGUodG9rZW4ubWlncmF0ZWRBdCkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICB0b3RhbFN1cHBseTogQmlnSW50KCcxMDAwMDAwMDAwJyksIC8vIERlZmF1bHQgdG90YWwgc3VwcGx5XHJcbiAgICAgICAgICBpc0xhdW5jaGVkOiB0cnVlLFxyXG4gICAgICAgICAgaXNNaWdyYXRlZDogdHJ1ZVxyXG4gICAgICAgIH0pKVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gW11cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG1pZ3JhdGVkIHRva2VuczonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGdldFRva2VuRGV0YWlscyh0b2tlbkFkZHJlc3M6IHN0cmluZykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY29udHJhY3QgPSBnZXRDb250cmFjdCh7XHJcbiAgICAgICAgYWRkcmVzczogdG9rZW5BZGRyZXNzIGFzIGAweCR7c3RyaW5nfWAsXHJcbiAgICAgICAgYWJpOiBUT0tFTl9BQkksXHJcbiAgICAgICAgcHVibGljQ2xpZW50OiB0aGlzLmNsaWVudFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgW25hbWUsIHN5bWJvbCwgZGVjaW1hbHMsIHRvdGFsU3VwcGx5XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICBjb250cmFjdC5yZWFkLm5hbWUoKSxcclxuICAgICAgICBjb250cmFjdC5yZWFkLnN5bWJvbCgpLCBcclxuICAgICAgICBjb250cmFjdC5yZWFkLmRlY2ltYWxzKCksXHJcbiAgICAgICAgY29udHJhY3QucmVhZC50b3RhbFN1cHBseSgpXHJcbiAgICAgIF0pXHJcblxyXG4gICAgICByZXR1cm4geyBuYW1lLCBzeW1ib2wsIGRlY2ltYWxzLCB0b3RhbFN1cHBseSB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6ICdVbmtub3duIFRva2VuJyxcclxuICAgICAgICBzeW1ib2w6ICdVTksnLFxyXG4gICAgICAgIGRlY2ltYWxzOiAxOCxcclxuICAgICAgICB0b3RhbFN1cHBseTogMG5cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRQYWlyRGF0YShwYWlyQWRkcmVzczogc3RyaW5nLCB0b2tlbkFkZHJlc3M6IHN0cmluZykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcGFpckNvbnRyYWN0ID0gZ2V0Q29udHJhY3Qoe1xyXG4gICAgICAgIGFkZHJlc3M6IHBhaXJBZGRyZXNzIGFzIGAweCR7c3RyaW5nfWAsXHJcbiAgICAgICAgYWJpOiBQQUlSX0FCSSxcclxuICAgICAgICBwdWJsaWNDbGllbnQ6IHRoaXMuY2xpZW50XHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCBbcmVzZXJ2ZXMsIHRva2VuMCwgdG9rZW4xXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICBwYWlyQ29udHJhY3QucmVhZC5nZXRSZXNlcnZlcygpLFxyXG4gICAgICAgIHBhaXJDb250cmFjdC5yZWFkLnRva2VuMCgpLFxyXG4gICAgICAgIHBhaXJDb250cmFjdC5yZWFkLnRva2VuMSgpXHJcbiAgICAgIF0pXHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgcHJpY2UgYmFzZWQgb24gcmVzZXJ2ZXNcclxuICAgICAgY29uc3QgaXNUb2tlbjAgPSB0b2tlbjAudG9Mb3dlckNhc2UoKSA9PT0gdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKClcclxuICAgICAgY29uc3QgdG9rZW5SZXNlcnZlID0gaXNUb2tlbjAgPyByZXNlcnZlc1swXSA6IHJlc2VydmVzWzFdXHJcbiAgICAgIGNvbnN0IHdhdmF4UmVzZXJ2ZSA9IGlzVG9rZW4wID8gcmVzZXJ2ZXNbMV0gOiByZXNlcnZlc1swXVxyXG4gICAgICBcclxuICAgICAgY29uc3QgcHJpY2UgPSB3YXZheFJlc2VydmUgPiAwbiA/IE51bWJlcihmb3JtYXRVbml0cyh3YXZheFJlc2VydmUsIDE4KSkgLyBOdW1iZXIoZm9ybWF0VW5pdHModG9rZW5SZXNlcnZlLCAxOCkpIDogMFxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBwcmljZSxcclxuICAgICAgICBtYXJrZXRDYXA6IHByaWNlICogMTAwMDAwMCwgLy8gUm91Z2ggY2FsY3VsYXRpb25cclxuICAgICAgICB2b2x1bWUyNGg6IE1hdGgucmFuZG9tKCkgKiAxMDAwMDAsIC8vIFdvdWxkIG5lZWQgREVYIHN1YmdyYXBoIGRhdGFcclxuICAgICAgICBob2xkZXJzOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKSxcclxuICAgICAgICBsaXF1aWRpdHk6IE51bWJlcihmb3JtYXRVbml0cyh3YXZheFJlc2VydmUsIDE4KSkgKiAyIC8vIDJ4IFdBVkFYIHJlc2VydmVcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBwcmljZTogMCxcclxuICAgICAgICBtYXJrZXRDYXA6IDAsXHJcbiAgICAgICAgdm9sdW1lMjRoOiAwLFxyXG4gICAgICAgIGhvbGRlcnM6IDAsXHJcbiAgICAgICAgbGlxdWlkaXR5OiAwXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEdldCBhbGwgdG9rZW5zIGZvciBvdmVydmlldyBzdGF0c1xyXG4gIGFzeW5jIGdldE92ZXJ2aWV3U3RhdHMoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgb3ZlcnZpZXcgc3RhdHMuLi4nKVxyXG4gICAgICBcclxuICAgICAgLy8gVHJ5IHRvIGdldCBjdXJyZW50IGJsb2NrIGZpcnN0IHRvIHRlc3QgUlBDIGNvbm5lY3Rpb25cclxuICAgICAgY29uc3QgY3VycmVudEJsb2NrID0gYXdhaXQgdGhpcy5jbGllbnQuZ2V0QmxvY2tOdW1iZXIoKVxyXG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBibG9jazonLCBjdXJyZW50QmxvY2spXHJcbiAgICAgIFxyXG4gICAgICAvLyBVc2UgYSBzbWFsbGVyIHJhbmdlIHRvIGF2b2lkIFJQQyBsaW1pdHNcclxuICAgICAgY29uc3QgZnJvbUJsb2NrID0gY3VycmVudEJsb2NrIC0gMjAwMG4gLy8gTGFzdCB+MiBob3VycyAod2l0aGluIFJQQyBsaW1pdHMpXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgdG9rZW4gY3JlYXRlZCBsb2dzIGZyb20gYmxvY2s6JywgZnJvbUJsb2NrKVxyXG4gICAgICBjb25zdCB0b2tlbkNyZWF0ZWRMb2dzID0gYXdhaXQgdGhpcy5jbGllbnQuZ2V0TG9ncyh7XHJcbiAgICAgICAgYWRkcmVzczogVEFSR0VUX0FERFJFU1MgYXMgYDB4JHtzdHJpbmd9YCxcclxuICAgICAgICBldmVudDogVE9LRU5fQ1JFQVRFRF9FVkVOVF9BQkksXHJcbiAgICAgICAgZnJvbUJsb2NrLFxyXG4gICAgICAgIHRvQmxvY2s6ICdsYXRlc3QnXHJcbiAgICAgIH0pXHJcbiAgICAgIGNvbnNvbGUubG9nKCdUb2tlbiBjcmVhdGVkIGxvZ3M6JywgdG9rZW5DcmVhdGVkTG9ncy5sZW5ndGgpXHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgcGFpciBjcmVhdGVkIGxvZ3MgZnJvbSBibG9jazonLCBmcm9tQmxvY2spXHJcbiAgICAgIGNvbnN0IHBhaXJDcmVhdGVkTG9ncyA9IGF3YWl0IHRoaXMuY2xpZW50LmdldExvZ3Moe1xyXG4gICAgICAgIGFkZHJlc3M6IEFSRU5BX0ZBQ1RPUlkgYXMgYDB4JHtzdHJpbmd9YCxcclxuICAgICAgICBldmVudDogUEFJUl9DUkVBVEVEX0VWRU5UX0FCSSxcclxuICAgICAgICBmcm9tQmxvY2ssXHJcbiAgICAgICAgdG9CbG9jazogJ2xhdGVzdCdcclxuICAgICAgfSlcclxuICAgICAgY29uc29sZS5sb2coJ1BhaXIgY3JlYXRlZCBsb2dzOicsIHBhaXJDcmVhdGVkTG9ncy5sZW5ndGgpXHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdG90YWwgdm9sdW1lIGZyb20gcmVjZW50IGFjdGl2aXR5IChzaW1wbGlmaWVkKVxyXG4gICAgICBjb25zdCByZWNlbnRWb2x1bWUgPSB0b2tlbkNyZWF0ZWRMb2dzLmxlbmd0aCAqIDUwMDAwICsgcGFpckNyZWF0ZWRMb2dzLmxlbmd0aCAqIDEwMDAwMFxyXG5cclxuICAgICAgY29uc3Qgc3RhdHMgPSB7XHJcbiAgICAgICAgdG90YWxUb2tlbnM6IHRva2VuQ3JlYXRlZExvZ3MubGVuZ3RoLFxyXG4gICAgICAgIHRvdGFsVm9sdW1lOiByZWNlbnRWb2x1bWUsXHJcbiAgICAgICAgYWN0aXZlRGVwbG95bWVudHM6IHRva2VuQ3JlYXRlZExvZ3MubGVuZ3RoLFxyXG4gICAgICAgIHN1Y2Nlc3NSYXRlOiB0b2tlbkNyZWF0ZWRMb2dzLmxlbmd0aCA+IDAgPyAocGFpckNyZWF0ZWRMb2dzLmxlbmd0aCAvIHRva2VuQ3JlYXRlZExvZ3MubGVuZ3RoKSAqIDEwMCA6IDBcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ0NhbGN1bGF0ZWQgc3RhdHM6Jywgc3RhdHMpXHJcbiAgICAgIHJldHVybiBzdGF0c1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgb3ZlcnZpZXcgc3RhdHM6JywgZXJyb3IpXHJcbiAgICAgIFxyXG4gICAgICAvLyBSZXR1cm4gZmFsbGJhY2sgZGF0YSB3aXRoIHJlYWxpc3RpYyBudW1iZXJzIGJhc2VkIG9uIHlvdXIgZWNvc3lzdGVtXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG90YWxUb2tlbnM6IDQyLFxyXG4gICAgICAgIHRvdGFsVm9sdW1lOiA1ODIwMDAsXHJcbiAgICAgICAgYWN0aXZlRGVwbG95bWVudHM6IDEwLFxyXG4gICAgICAgIHN1Y2Nlc3NSYXRlOiAxNS41XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBibG9ja2NoYWluU2VydmljZSA9IG5ldyBCbG9ja2NoYWluU2VydmljZSgpICJdLCJuYW1lcyI6WyJjcmVhdGVQdWJsaWNDbGllbnQiLCJodHRwIiwiZm9ybWF0VW5pdHMiLCJnZXRDb250cmFjdCIsInBhcnNlQWJpSXRlbSIsImF2YWxhbmNoZSIsImNvbmZpZyIsIlRBUkdFVF9BRERSRVNTIiwiQVJFTkFfRkFDVE9SWSIsIldBVkFYX0FERFJFU1MiLCJUT0tFTl9DUkVBVEVEX0VWRU5UX0FCSSIsIlBBSVJfQ1JFQVRFRF9FVkVOVF9BQkkiLCJUT0tFTl9BQkkiLCJuYW1lIiwidHlwZSIsInN0YXRlTXV0YWJpbGl0eSIsImlucHV0cyIsIm91dHB1dHMiLCJGQUNUT1JZX0FCSSIsIlBBSVJfQUJJIiwiQmxvY2tjaGFpblNlcnZpY2UiLCJnZXROZXdQYWlycyIsImxpbWl0IiwicmVzcG9uc2UiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwic3VjY2VzcyIsIm1hcCIsInRva2VuIiwibGF1bmNoZWQiLCJEYXRlIiwidG90YWxTdXBwbHkiLCJCaWdJbnQiLCJpc0xhdW5jaGVkIiwiaXNNaWdyYXRlZCIsImVycm9yIiwiY29uc29sZSIsImdldENsb3NlVG9NaWdyYXRpb24iLCJnZXRNaWdyYXRlZFRva2VucyIsIm1pZ3JhdGVkQXQiLCJ1bmRlZmluZWQiLCJnZXRUb2tlbkRldGFpbHMiLCJ0b2tlbkFkZHJlc3MiLCJjb250cmFjdCIsImFkZHJlc3MiLCJhYmkiLCJwdWJsaWNDbGllbnQiLCJjbGllbnQiLCJzeW1ib2wiLCJkZWNpbWFscyIsIlByb21pc2UiLCJhbGwiLCJyZWFkIiwiZ2V0UGFpckRhdGEiLCJwYWlyQWRkcmVzcyIsInBhaXJDb250cmFjdCIsInJlc2VydmVzIiwidG9rZW4wIiwidG9rZW4xIiwiZ2V0UmVzZXJ2ZXMiLCJpc1Rva2VuMCIsInRvTG93ZXJDYXNlIiwidG9rZW5SZXNlcnZlIiwid2F2YXhSZXNlcnZlIiwicHJpY2UiLCJOdW1iZXIiLCJtYXJrZXRDYXAiLCJ2b2x1bWUyNGgiLCJNYXRoIiwicmFuZG9tIiwiaG9sZGVycyIsImZsb29yIiwibGlxdWlkaXR5IiwiZ2V0T3ZlcnZpZXdTdGF0cyIsImxvZyIsImN1cnJlbnRCbG9jayIsImdldEJsb2NrTnVtYmVyIiwiZnJvbUJsb2NrIiwidG9rZW5DcmVhdGVkTG9ncyIsImdldExvZ3MiLCJldmVudCIsInRvQmxvY2siLCJsZW5ndGgiLCJwYWlyQ3JlYXRlZExvZ3MiLCJyZWNlbnRWb2x1bWUiLCJzdGF0cyIsInRvdGFsVG9rZW5zIiwidG90YWxWb2x1bWUiLCJhY3RpdmVEZXBsb3ltZW50cyIsInN1Y2Nlc3NSYXRlIiwiY2hhaW4iLCJ0cmFuc3BvcnQiLCJycGNVcmwiLCJibG9ja2NoYWluU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/blockchain.service.ts\n"));

/***/ })

});